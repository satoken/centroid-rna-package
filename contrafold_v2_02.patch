diff -urN contrafold_v2_02.orig/src/InferenceEngine.hpp contrafold/src/InferenceEngine.hpp
--- contrafold_v2_02.orig/src/InferenceEngine.hpp	2008-08-14 09:08:31.000000000 +0900
+++ contrafold/src/InferenceEngine.hpp	2008-10-27 15:53:42.682134440 +0900
@@ -1,5 +1,5 @@
 //////////////////////////////////////////////////////////////////////
-// InferenceEngine.hpp
+// InferencaeEngine.hpp
 //////////////////////////////////////////////////////////////////////
 
 #ifndef INFERENCEENGINE_HPP
@@ -26,6 +26,7 @@
     int is_complementary[M+1][M+1];
     bool cache_initialized;
     ParameterManager<RealT> *parameter_manager;
+    int max_bp_dist;
     
     // dimensions
     int L, SIZE;
@@ -223,11 +224,13 @@
 
     // cache
     std::pair<RealT,RealT> cache_score_single[C_MAX_SINGLE_LENGTH+1][C_MAX_SINGLE_LENGTH+1];
+#if ( PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR ) && FAST_HELIX_LENGTHS 
     std::vector<std::pair<RealT,RealT> > cache_score_helix_sums;
+#endif
 
     void FillScores(typename std::vector<std::pair<RealT, RealT> >::iterator begin, typename std::vector<std::pair<RealT, RealT> >::iterator end, RealT value);
     void FillCounts(typename std::vector<std::pair<RealT, RealT> >::iterator begin, typename std::vector<std::pair<RealT, RealT> >::iterator end, RealT value);
-    int ComputeRowOffset(int i, int N) const;
+    int ComputeRowOffset(int i, int N, int w) const;
     bool IsComplementary(int i, int j) const;
     
     RealT ScoreJunctionA(int i, int j) const;
@@ -262,7 +265,7 @@
 public:
 
     // constructor and destructor
-    InferenceEngine(bool allow_noncomplementary);
+    InferenceEngine(bool allow_noncomplementary, int max_bp_dist=0);
     ~InferenceEngine();
 
     // register params with the parameter manager
@@ -293,7 +296,10 @@
     std::vector<RealT> ComputeFeatureCountExpectations();
     void ComputePosterior();
     std::vector<int> PredictPairingsPosterior(const RealT gamma) const;
+    std::vector<int> PredictPairingsStochasticTraceback() const;
     RealT *GetPosterior(const RealT posterior_cutoff) const;
+    RealT *GetPosterior(const RealT posterior_cutoff, std::vector<RealT>& p) const;
+
 };
 
 #include "InferenceEngine.ipp"
diff -urN contrafold_v2_02.orig/src/InferenceEngine.ipp contrafold/src/InferenceEngine.ipp
--- contrafold_v2_02.orig/src/InferenceEngine.ipp	2008-08-14 09:08:31.000000000 +0900
+++ contrafold/src/InferenceEngine.ipp	2008-10-27 16:38:31.799830735 +0900
@@ -6,6 +6,11 @@
 // Wrapper macros for certain model features.
 //////////////////////////////////////////////////////////////////////
 
+#include <list>
+#include <utility>
+#include <cassert>
+#include <cstdlib>
+
 // score for leaving s[i] unpaired
 
 #if defined(HAMMING_LOSS)
@@ -166,13 +171,26 @@
 //////////////////////////////////////////////////////////////////////
 
 template<class RealT>
-int InferenceEngine<RealT>::ComputeRowOffset(int i, int N) const
+int InferenceEngine<RealT>::ComputeRowOffset(int i, int N, int w /*=0*/) const
 {
     Assert(i >= 0 && i <= N, "Index out-of-bounds.");
-    
+#define USE_EFFICIENT_WINDOW
+#ifdef USE_EFFICIENT_WINDOW
+    if (w==0)
+    {
+	// equivalent to:
+	//   return N*(N+1)/2 - (N-i)*(N-i+1)/2 - i;
+	return i*(N+N-i-1)/2;
+    }
+    else
+    {
+	return i*w - i;
+    }
+#else
     // equivalent to:
     //   return N*(N+1)/2 - (N-i)*(N-i+1)/2 - i;
     return i*(N+N-i-1)/2;
+#endif
 }
 
 //////////////////////////////////////////////////////////////////////
@@ -210,10 +228,11 @@
 //////////////////////////////////////////////////////////////////////
 
 template<class RealT>
-InferenceEngine<RealT>::InferenceEngine(bool allow_noncomplementary) :
+InferenceEngine<RealT>::InferenceEngine(bool allow_noncomplementary, int max_bp_dist) :
     allow_noncomplementary(allow_noncomplementary),
     cache_initialized(false),
     parameter_manager(NULL),
+    max_bp_dist(max_bp_dist),
     L(0),
     SIZE(0)
 #if PROFILE
@@ -222,6 +241,9 @@
 #endif
 
 {
+    // initalize a pseudo random number generator
+    srand(static_cast<unsigned int>(time(NULL)));
+
     // precompute mapping from characters to index representation
     std::memset(char_mapping, BYTE(alphabet.size()), 256);
     for (size_t i = 0; i < alphabet.size(); i++)
@@ -795,7 +817,14 @@
     
     // compute dimensions
     L = sstruct.GetLength();
+#ifdef USE_EFFICIENT_WINDOW
+    if (max_bp_dist==0)
+        SIZE = (L+1)*(L+2) / 2;
+    else
+        SIZE = (L+1)*max_bp_dist;
+#else
     SIZE = (L+1)*(L+2) / 2;
+#endif
 #if PROFILE
     N = sstruct.GetNumSequences();
     SIZE2 = (L+1)*(L+1);
@@ -864,7 +893,7 @@
 
 #endif
 
-#if FAST_HELIX_LENGTHS
+#if ( PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR ) && FAST_HELIX_LENGTHS 
     cache_score_helix_sums.clear();                  cache_score_helix_sums.resize((2*L+1)*L);
 #endif
 
@@ -895,7 +924,7 @@
     // set the loss for each unpaired position to zero
     for (int i = 0; i <= L; i++)
     {
-        offset[i] = ComputeRowOffset(i,L+1);
+        offset[i] = ComputeRowOffset(i,L+1,max_bp_dist);
         allow_unpaired_position[i] = 1;
         loss_unpaired_position[i] = RealT(0);
     }
@@ -924,7 +953,8 @@
         // for each pair of non-complementary letters in the sequence, disallow the pairing
         for (int i = 1; i <= L; i++)
         {
-            for (int j = i+1; j <= L; j++)
+            int l = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+            for (int j = i+1; j <= l; j++)
             {
                 if (!IsComplementary(i,j))
                     allow_paired[offset[i]+j] = 0;
@@ -1150,12 +1180,13 @@
 
 #endif
 
-#if FAST_HELIX_LENGTHS
+#if ( PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR ) && FAST_HELIX_LENGTHS 
     // precompute helix partial sums
     FillScores(cache_score_helix_sums.begin(), cache_score_helix_sums.end(), RealT(0));
     for (int i = L; i >= 1; i--)
     {
-        for (int j = i+3; j <= L; j++)
+        int l = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = i+3; j <= l; j++)
         {
             cache_score_helix_sums[(i+j)*L+j-i].first = cache_score_helix_sums[(i+j)*L+j-i-2].first;
             if (allow_paired[offset[i+1]+j-1])
@@ -1291,7 +1322,7 @@
         for (int l2 = 0; l2 <= C_MAX_SINGLE_LENGTH; l2++)
             cache_score_single[l1][l2].second = RealT(0);
     
-#if FAST_HELIX_LENGTHS
+#if ( PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR ) && FAST_HELIX_LENGTHS 
     FillCounts(cache_score_helix_sums.begin(), cache_score_helix_sums.end(), RealT(0));
 #endif
 
@@ -1356,14 +1387,15 @@
 template<class RealT>
 void InferenceEngine<RealT>::FinalizeCounts()
 {
-#if FAST_HELIX_LENGTHS
+#if ( PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR ) && FAST_HELIX_LENGTHS 
 
     // reverse helix partial sums    
     std::vector<std::pair<RealT,RealT> > reverse_sums(cache_score_helix_sums);
     
     for (int i = 1; i <= L; i++)
     {
-        for (int j = L; j >= i+3; j--)
+        int l = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = l; j >= i+3; j--)
         {
             // the "if" conditions here can be omitted
             
@@ -1682,7 +1714,8 @@
     {
         loss_unpaired[offset[i]+i] = RealT(0);
         loss_paired[offset[i]+i] = RealT(NEG_INF);
-        for (int j = i+1; j <= L; j++)
+        int l = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = i+1; j <= l; j++)
         {
             loss_unpaired[offset[i]+j] = 
                 loss_unpaired[offset[i]+j-1] +
@@ -1720,7 +1753,8 @@
     {
         allow_unpaired[offset[i]+i] = 1;
         allow_paired[offset[i]+i] = 0;
-        for (int j = i+1; j <= L; j++)
+        int l = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = i+1; j <= l; j++)
         {
             allow_unpaired[offset[i]+j] = 
                 allow_unpaired[offset[i]+j-1] && 
@@ -2042,7 +2076,7 @@
     Assert(0 <= i && i + 2 * m <= j && j <= L, "Helix boundaries invalid.");
     Assert(2 <= m && m <= D_MAX_HELIX_LENGTH, "Helix length invalid.");
     
-#if FAST_HELIX_LENGTHS
+#if ( PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR ) && FAST_HELIX_LENGTHS 
     
     return
         cache_score_helix_sums[(i+j+1)*L+j-i-1].first - cache_score_helix_sums[(i+j+1)*L+j-i-m-m+1].first
@@ -2073,7 +2107,7 @@
     Assert(0 <= i && i + 2 * m <= j && j <= L, "Helix boundaries invalid.");
     Assert(2 <= m && m <= D_MAX_HELIX_LENGTH, "Helix length invalid.");
     
-#if FAST_HELIX_LENGTHS
+#if ( PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR ) && FAST_HELIX_LENGTHS 
     
     cache_score_helix_sums[(i+j+1)*L+j-i-1].second += value;
     cache_score_helix_sums[(i+j+1)*L+j-i-m-m+1].second -= value;
@@ -2390,7 +2424,8 @@
         candidates.clear();
 #endif
         
-        for (int j = i; j <= L; j++)
+        int L2 = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = i; j <= L2; j++)
         {
             // FM2[i,j] = MAX (i<k<j : FM1[i,k] + FM[k,j])
 
@@ -2403,34 +2438,41 @@
                 UPDATE_MAX(FM2v, FM2t, FM1v[offset[i]+k] + FMv[offset[k]+j], k);
             
 #else
+            if (max_bp_dist==0)
+            {
             
 #if !CANDIDATE_LIST
             
-            if (i+2 <= j)
-            {
-                RealT *p1 = &(FM1v[offset[i]+i+1]);
-                RealT *p2 = &(FMv[offset[i+1]+j]);
-                for (register int k = i+1; k < j; k++)
+                if (i+2 <= j)
                 {
-                    UPDATE_MAX(FM2v, FM2t, (*p1) + (*p2), k);
-                    ++p1;
-                    p2 += L-k;
+                    RealT *p1 = &(FM1v[offset[i]+i+1]);
+                    RealT *p2 = &(FMv[offset[i+1]+j]);
+                    for (register int k = i+1; k < j; k++)
+                    {
+                        UPDATE_MAX(FM2v, FM2t, (*p1) + (*p2), k);
+                        ++p1;
+                        p2 += L-k;
+                    }
                 }
-            }
             
 #else
             
-            for (register size_t kp = 0; kp < candidates.size(); kp++)
-            {
-                register const int k = candidates[kp];
-                UPDATE_MAX(FM2v, FM2t, FM1v[offset[i]+k] + FMv[offset[k]+j], k);
-            }
+                for (register size_t kp = 0; kp < candidates.size(); kp++)
+                {
+                    register const int k = candidates[kp];
+                    UPDATE_MAX(FM2v, FM2t, FM1v[offset[i]+k] + FMv[offset[k]+j], k);
+                }
             
-            candidates_seen += (long long int) candidates.size();
-            candidates_possible += (long long int) std::max(j-i-1,0);
+                candidates_seen += (long long int) candidates.size();
+                candidates_possible += (long long int) std::max(j-i-1,0);
             
 #endif
-            
+            }
+            else
+            {
+                for (int k = i+1; k < j; k++)
+                    UPDATE_MAX(FM2v, FM2t, FM1v[offset[i]+k] + FMv[offset[k]+j], k);
+            }
 #endif
 
 #if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
@@ -2607,7 +2649,7 @@
             //
             // Multi-branch loops are scored as [a + b * (# unpaired) + c * (# branches)]
             
-            if (0 < i && j < L && allow_paired[offset[i]+j+1])
+            if (0 < i && j < L2 && allow_paired[offset[i]+j+1])
             {
                 
                 RealT best_v = RealT(NEG_INF);
@@ -2694,7 +2736,7 @@
             //
             //            (assuming 0 < i < i+2 <= j < L)
             
-            if (0 < i && i+2 <= j && j < L)
+            if (0 < i && i+2 <= j && j < L2)
             {
                 RealT best_v = RealT(NEG_INF);
                 int best_t = -1;
@@ -2749,7 +2791,7 @@
             //
             //            (assuming 0 < i < i+2 <= j < L)
             
-            if (0 < i && i+2 <= j && j < L)
+            if (0 < i && i+2 <= j && j < L2)
             {
                 RealT best_v = RealT(NEG_INF);
                 int best_t = -1;
@@ -2801,7 +2843,8 @@
         
         // compute MAX (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
         
-        for (int k = 0; k < j; k++)
+        int l = max_bp_dist==0 ? 0 : std::max(0,j-max_bp_dist);
+        for (int k = l; k < j; k++)
         {
             if (allow_paired[offset[k+1]+j])
             {
@@ -2952,7 +2995,7 @@
                 solution[j] = i+1;
                 traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
             }
-      break;
+            break;
             case TB_FM1_UNPAIRED:
             {
                 traceback_queue.push(make_triple(&FM1t[0], i+1, j));
@@ -3199,7 +3242,8 @@
 
     for (int i = L; i >= 0; i--)
     {
-        for (int j = i; j <= L; j++)
+        int L2 = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = i; j <= L2; j++)
         {
             
             // FM2[i,j] = SUM (i<k<j : FM1[i,k] + FM[k,j])
@@ -3212,19 +3256,25 @@
                 Fast_LogPlusEquals(FM2i, FM1i[offset[i]+k] + FMi[offset[k]+j]);
             
 #else
-            
-            if (i+2 <= j)
+            if (max_bp_dist==0)
             {
-                const RealT *p1 = &(FM1i[offset[i]+i+1]);
-                const RealT *p2 = &(FMi[offset[i+1]+j]);
-                for (register int k = i+1; k < j; k++)
+                if (i+2 <= j)
                 {
-                    Fast_LogPlusEquals(FM2i, (*p1) + (*p2));
-                    ++p1;
-                    p2 += L-k;
+                    const RealT *p1 = &(FM1i[offset[i]+i+1]);
+                    const RealT *p2 = &(FMi[offset[i+1]+j]);
+                    for (register int k = i+1; k < j; k++)
+                    {
+                        Fast_LogPlusEquals(FM2i, (*p1) + (*p2));
+                        ++p1;
+                        p2 += L-k;
+                    }
                 }
             }
-            
+            else
+            {
+                for (int k = i+1; k < j; k++)
+                    Fast_LogPlusEquals(FM2i, FM1i[offset[i]+k] + FMi[offset[k]+j]);
+            }
 #endif
             
 #if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
@@ -3381,7 +3431,7 @@
             //
             // Multi-branch loops are scored as [a + b * (# unpaired) + c * (# branches)]
             
-            if (0 < i && j < L && allow_paired[offset[i]+j+1])
+            if (0 < i && j < L2 && allow_paired[offset[i]+j+1])
             {
                 RealT sum_i = RealT(NEG_INF);
                 
@@ -3455,7 +3505,7 @@
             //
             //            (assuming 0 < i < i+2 <= j < L)
             
-            if (0 < i && i+2 <= j && j < L)
+            if (0 < i && i+2 <= j && j < L2)
             {
                 
                 RealT sum_i = RealT(NEG_INF);
@@ -3483,7 +3533,7 @@
             //
             //            (assuming 0 < i < i+2 <= j < L)
             
-            if (0 < i && i+2 <= j && j < L)
+            if (0 < i && i+2 <= j && j < L2)
             {
                 
                 RealT sum_i = RealT(NEG_INF);
@@ -3525,7 +3575,8 @@
         
         // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
         
-        for (int k = 0; k < j; k++)
+        int l = max_bp_dist==0 ? 0 : std::max(0,j-max_bp_dist);
+        for (int k = l; k < j; k++)
             if (allow_paired[offset[k+1]+j])
                 Fast_LogPlusEquals(sum_i, F5i[k] + FCi[offset[k+1]+j-1] + ScoreExternalPaired() + ScoreBasePair(k+1,j) + ScoreJunctionA(j,k));
         
@@ -3582,7 +3633,8 @@
         // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
         
         {
-            for (int k = 0; k < j; k++)
+            int l = max_bp_dist==0 ? 0 : std::max(0,j-max_bp_dist);
+            for (int k = l; k < j; k++)
             {
                 if (allow_paired[offset[k+1]+j])
                 {
@@ -3596,7 +3648,8 @@
     
     for (int i = 0; i <= L; i++)
     {
-        for (int j = L; j >= i; j--)
+        int L2 = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = L2; j >= i; j--)
         {
             RealT FM2o = RealT(NEG_INF);
             
@@ -3610,7 +3663,7 @@
             //
             //            (assuming 0 < i < i+2 <= j < L)
             
-            if (0 < i && i+2 <= j && j < L)
+            if (0 < i && i+2 <= j && j < L2)
             {
                 // compute SUM (i<k<j : FM1[i,k] + FM[k,j])
                 
@@ -3636,7 +3689,7 @@
             //
             //            (assuming 0 < i < i+2 <= j < L)
             
-            if (0 < i && i+2 <= j && j < L)
+            if (0 < i && i+2 <= j && j < L2)
             {
                 // compute FC[i+1,j-1] + ScoreJunctionA(j,i) + c + ScoreBP(i+1,j)
                 
@@ -3790,7 +3843,7 @@
             //
             // Multi-branch loops are scored as [a + b * (# unpaired) + c * (# branches)]
             
-            if (0 < i && j < L && allow_paired[offset[i]+j+1])
+            if (0 < i && j < L2 && allow_paired[offset[i]+j+1])
             {
                 // compute ScoreHairpin(i,j) -- do nothing
                 
@@ -3857,23 +3910,33 @@
             }
 
 #else
-            if (i+2 <= j)
+            if (max_bp_dist==0)
             {
-                RealT *p1i = &(FM1i[offset[i]+i+1]);
-                RealT *p2i = &(FMi[offset[i+1]+j]);
-                RealT *p1o = &(FM1o[offset[i]+i+1]);
-                RealT *p2o = &(FMo[offset[i+1]+j]);
-                for (register int k = i+1; k < j; k++)
+                if (i+2 <= j)
                 {
-                    Fast_LogPlusEquals(*p1o, FM2o + *p2i);
-                    Fast_LogPlusEquals(*p2o, FM2o + *p1i);
-                    ++p1i;
-                    ++p1o;
-                    p2i += L-k;
-                    p2o += L-k;
+                    RealT *p1i = &(FM1i[offset[i]+i+1]);
+                    RealT *p2i = &(FMi[offset[i+1]+j]);
+                    RealT *p1o = &(FM1o[offset[i]+i+1]);
+                    RealT *p2o = &(FMo[offset[i+1]+j]);
+                    for (register int k = i+1; k < j; k++)
+                    {
+                        Fast_LogPlusEquals(*p1o, FM2o + *p2i);
+                        Fast_LogPlusEquals(*p2o, FM2o + *p1i);
+                        ++p1i;
+                        ++p1o;
+                        p2i += L-k;
+                        p2o += L-k;
+                    }
+                }
+            }
+            else
+            {
+                for (int k = i+1; k < j; k++)
+                {
+                    Fast_LogPlusEquals(FM1o[offset[i]+k], FM2o + FMi[offset[k]+j]);
+                    Fast_LogPlusEquals(FMo[offset[k]+j], FM2o + FM1i[offset[i]+k]);
                 }
             }
-            
 #endif
         }
     }
@@ -3920,7 +3983,8 @@
     
     for (int i = L; i >= 0; i--)
     {
-        for (int j = i; j <= L; j++)
+        int L2 = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = i; j <= L2; j++)
         {
 
             // FM2[i,j] = SUM (i<k<j : FM1[i,k] + FM[k,j])
@@ -3933,19 +3997,25 @@
                 Fast_LogPlusEquals(FM2i, FM1i[offset[i]+k] + FMi[offset[k]+j]);
             
 #else
-            
-            if (i+2 <= j)
+            if (max_bp_dist==0)
             {
-                const RealT *p1 = &(FM1i[offset[i]+i+1]);
-                const RealT *p2 = &(FMi[offset[i+1]+j]);
-                for (register int k = i+1; k < j; k++)
+                if (i+2 <= j)
                 {
-                    Fast_LogPlusEquals(FM2i, (*p1) + (*p2));
-                    ++p1;
-                    p2 += L-k;
+                    const RealT *p1 = &(FM1i[offset[i]+i+1]);
+                    const RealT *p2 = &(FMi[offset[i+1]+j]);
+                    for (register int k = i+1; k < j; k++)
+                    {
+                        Fast_LogPlusEquals(FM2i, (*p1) + (*p2));
+                        ++p1;
+                        p2 += L-k;
+                    }
                 }
             }
-            
+            else
+            {
+                for (int k = i+1; k < j; k++)
+                    Fast_LogPlusEquals(FM2i, FM1i[offset[i]+k] + FMi[offset[k]+j]);
+            }
 #endif
             
 #if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
@@ -4104,7 +4174,7 @@
             //
             // Multi-branch loops are scored as [a + b * (# unpaired) + c * (# branches)]
             
-            if (0 < i && j < L && allow_paired[offset[i]+j+1])
+            if (0 < i && j < L2 && allow_paired[offset[i]+j+1])
             {
                 RealT outside = FCo[offset[i]+j] - Z;
                 
@@ -4198,7 +4268,7 @@
             //
             //            (assuming 0 < i < i+2 <= j < L)
             
-            if (0 < i && i+2 <= j && j < L)
+            if (0 < i && i+2 <= j && j < L2)
             {
                 
                 // compute FC[i+1,j-1] + ScoreJunctionA(j,i) + c + ScoreBP(i+1,j)
@@ -4229,7 +4299,7 @@
             //
             //            (assuming 0 < i < i+2 <= j < L)
             
-            if (0 < i && i+2 <= j && j < L)
+            if (0 < i && i+2 <= j && j < L2)
             {
                 
                 // compute SUM (i<k<j : FM1[i,k] + FM[k,j]) -- do nothing
@@ -4262,7 +4332,8 @@
         
         // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
         
-        for (int k = 0; k < j; k++)
+        int l = max_bp_dist==0 ? 0 : std::max(0,j-max_bp_dist);
+        for (int k = l; k < j; k++)
         {
             if (allow_paired[offset[k+1]+j])
             {
@@ -4302,9 +4373,11 @@
     
     for (int i = L; i >= 0; i--)
     {
-        for (int j = i; j <= L; j++)
+        int L2 = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = i; j <= L2; j++)
         {
-            
+#if 0                   // FM2 is not required
+
             // FM2[i,j] = SUM (i<k<j : FM1[i,k] + FM[k,j])
             
             RealT FM2i = RealT(NEG_INF);
@@ -4329,6 +4402,7 @@
             }
       
 #endif
+#endif
 
 #if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
             
@@ -4476,16 +4550,15 @@
             //
             // Multi-branch loops are scored as [a + b * (# unpaired) + c * (# branches)]
             
-            if (0 < i && j < L && allow_paired[offset[i]+j+1])
+            if (0 < i && j < L2 && allow_paired[offset[i]+j+1])
             {
-                
                 RealT outside = FCo[offset[i]+j] - Z;
-                
+#if 0                
                 // compute ScoreHairpin(i,j)
-                
                 if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
                     CountHairpin(i,j,Fast_Exp(outside + ScoreHairpin(i,j)));
-                
+#endif
+
                 // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
                 
 #if !FAST_SINGLE_BRANCH_LOOPS
@@ -4551,7 +4624,6 @@
             //                 FM1[i+1,j] + b                                          if i+2<=j]
             //
             //            (assuming 0 < i < i+2 <= j < L)
-            
             if (0 < i && i+2 <= j && j < L)
             {
                 
@@ -4581,7 +4653,7 @@
             // Compute FM1[i,j] -- do nothing
         }
     }
-    
+
     for (int j = 1; j <= L; j++)
     {
         
@@ -4597,7 +4669,8 @@
         
         // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
         
-        for (int k = 0; k < j; k++)
+        int l = max_bp_dist==0 ? 0 : std::max(0,j-max_bp_dist);
+        for (int k = l; k < j; k++)
         {
             if (allow_paired[offset[k+1]+j])
                 posterior[offset[k+1]+j] += Fast_Exp(outside + F5i[k] + FCi[offset[k+1]+j-1] + ScoreExternalPaired() + ScoreBasePair(k+1,j) + ScoreJunctionA(j,k));
@@ -4606,7 +4679,8 @@
 
     for (int i = 1; i <= L; i++)
     {
-        for (int j = i+1; j <= L; j++)
+        int l = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        for (int j = i+1; j <= l; j++)
         {
             posterior[offset[i]+j] = Clip(posterior[offset[i]+j], RealT(0), RealT(1));
         }
@@ -4627,9 +4701,9 @@
 #if SHOW_TIMINGS
     double starting_time = GetSystemTime();
 #endif
-    RealT* unpaired_posterior  = new RealT[L+1];
-    RealT* score               = new RealT[SIZE];
-    int* traceback             = new int[SIZE];
+    std::vector<RealT> unpaired_posterior(L+1);
+    std::vector<RealT> score(SIZE);
+    std::vector<int> traceback(SIZE);
     
     // compute the scores for unpaired nucleotides
     
@@ -4644,8 +4718,8 @@
     
     // initialize matrices
     
-    std::fill(score, score+SIZE, RealT(-1.0));
-    std::fill(traceback, traceback+SIZE, -1);
+    std::fill(score.begin(), score.end(), RealT(-1.0));
+    std::fill(traceback.begin(), traceback.end(), -1);
     
     // dynamic programming
     
@@ -4677,16 +4751,22 @@
                         UPDATE_MAX(this_score, this_traceback, score[offset[i]+k] + score[offset[k]+j], k+4);	
                     
 #else
-                    
-                    RealT *p1 = &(score[offset[i]+i+1]);
-                    RealT *p2 = &(score[offset[i+1]+j]);
-                    for (register int k = i+1; k < j; k++)
+                    if (max_bp_dist==0)
                     {
-                        UPDATE_MAX(this_score, this_traceback, (*p1) + (*p2), k+4);
-                        ++p1;
-                        p2 += L-k;
+                        RealT *p1 = &(score[offset[i]+i+1]);
+                        RealT *p2 = &(score[offset[i+1]+j]);
+                        for (register int k = i+1; k < j; k++)
+                        {
+                            UPDATE_MAX(this_score, this_traceback, (*p1) + (*p2), k+4);
+                            ++p1;
+                            p2 += L-k;
+                        }
+                    }
+                    else
+                    {
+                        for (int k = i+1; k < j; k++)
+                            UPDATE_MAX(this_score, this_traceback, score[offset[i]+k] + score[offset[k]+j], k+4);
                     }
-                    
 #endif
                 }
             }
@@ -4743,6 +4823,325 @@
     return solution;
 }
 
+double rand01()
+{
+    return rand()/(RAND_MAX+1.0);
+}
+
+template < class T, class RealT >
+class Roulette
+{
+public:
+    Roulette()
+        : t_(), sum_(0)
+    { }
+        
+    void add(T t, RealT v)
+    {
+        t_.push_back(std::make_pair(t, v));
+        sum_ += v;
+    }
+    
+    T choose() const
+    {
+        RealT r = rand01() * sum_;
+        RealT s = 0.0;
+        typename std::list< std::pair<T,RealT> >::const_iterator x;
+        for (x=t_.begin(); x!=t_.end(); ++x)
+        {
+            s += x->second;
+            if (r<s) return x->first;
+        }
+        return t_.back().first;
+    }
+
+private:
+    std::list<std::pair<T,RealT> > t_;
+    RealT sum_;
+};
+
+
+// stochastic traceback algorithm
+template<class RealT>
+std::vector<int> InferenceEngine<RealT>::PredictPairingsStochasticTraceback() const
+{
+    enum { ST_FC, ST_F5, ST_FM, ST_FM1, ST_FE, ST_FN };
+
+    std::vector<int> solution(L+1,SStruct::UNPAIRED);
+    solution[0] = SStruct::UNKNOWN;
+
+    std::queue<triple<int,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(int(ST_F5), 0, L));
+
+    while (!traceback_queue.empty())
+    {
+        triple<int,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int i = t.second;
+        const int j = t.third;
+        int L2 = max_bp_dist==0 ? L : std::min(L,i+max_bp_dist);
+        const RealT Z = ComputeLogPartitionCoefficient();
+
+        switch (t.first)
+        {
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+        case ST_FC:
+            break;
+        case ST_FE:
+            break;
+        case ST_FN:
+            break;
+#else
+        case ST_FC:
+        {
+            if (0 < i && j < L2 && allow_paired[offset[i]+j+1]) // ???
+            {
+                Roulette<int,RealT> roulette;
+                RealT outside = FCo[offset[i]+j] - Z;
+                
+                // compute ScoreHairpin(i,j)
+                if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
+                    roulette.add(EncodeTraceback(TB_FC_HAIRPIN,0), Fast_Exp(outside + ScoreHairpin(i,j)));
+                
+                // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
+#if 1 //!FAST_SINGLE_BRANCH_LOOPS
+                for (int p = i; p <= std::min(i+C_MAX_SINGLE_LENGTH,j); p++)
+                {
+                    if (p > i && !allow_unpaired_position[p]) break;
+                    int q_min = std::max(p+2,p-i+j-C_MAX_SINGLE_LENGTH);
+                    for (int q = j; q >= q_min; q--)
+                    {
+                        if (q < j && !allow_unpaired_position[q+1]) break;
+                        if (!allow_paired[offset[p+1]+q]) continue;
+
+                        if (p == i && q == j)
+                        {
+                            roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                         Fast_Exp(outside + ScoreBasePair(i+1,j) + ScoreHelixStacking(i,j+1) +
+                                                  FCi[offset[p+1]+q-1]));
+                        }
+                        else
+                        {
+                            roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                         Fast_Exp(outside + ScoreSingle(i,j,p,q) + FCi[offset[p+1]+q-1]));
+                        }
+                    }
+                }
+#else
+                {
+                    RealT score_helix = (i+2 <= j ? outside + ScoreBasePair(i+1,j) + ScoreHelixStacking(i,j+1) : 0);
+                    RealT score_other = outside + ScoreJunctionB(i,j);
+                    
+                    for (int p = i; p <= std::min(i+C_MAX_SINGLE_LENGTH,j); p++)
+                    {
+                        if (p > i && !allow_unpaired_position[p]) break;
+                        int q_min = std::max(p+2,p-i+j-C_MAX_SINGLE_LENGTH);
+                        const RealT *FCptr = &(FCi[offset[p+1]-1]);
+                        for (int q = j; q >= q_min; q--)
+                        {
+                            if (q < j && !allow_unpaired_position[q+1]) break;
+                            if (!allow_paired[offset[p+1]+q]) continue;
+                            
+                            if (p == i && q == j)
+                            {
+                                RealT value = Fast_Exp(score_helix + FCptr[q]);
+                                cache_score_single[0][0].second += value;
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q), value);
+                            }
+                            else
+                            {
+                                RealT value = Fast_Exp(score_other + cache_score_single[p-i][j-q].first +
+                                                       FCptr[q] + ScoreBasePair(p+1,q) + 
+                                                       ScoreJunctionB(q,p) + ScoreSingleNucleotides(i,j,p,q));
+                                cache_score_single[p-i][j-q].second += value;
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q), value);
+                            }
+                        }
+                    }
+                }
+#endif
+                // compute SUM (i<k<j : FM1[i,k] + FM[k,j] + ScoreJunctionA(i,j) + a + c)
+                for (int k=i+1; k < j; k++)
+                {
+                    RealT FM2i = FM1i[offset[i]+k] + FMi[offset[k]+j];
+                    RealT val = Fast_Exp(outside + FM2i + ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase());
+                    roulette.add(EncodeTraceback(TB_FC_BIFURCATION, k), val);
+                }
+
+                // choose
+                std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                switch (traceback.first)
+                {
+                case TB_FC_HAIRPIN: 
+                    break;
+                case TB_FC_SINGLE: 
+                {
+                    const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                    const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                    solution[p+1] = q;
+                    solution[q] = p+1;
+                    traceback_queue.push(make_triple(int(ST_FC), p+1, q-1));
+                }
+                break;
+                case TB_FC_BIFURCATION:
+                {
+                    const int k = traceback.second;
+                    traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                    traceback_queue.push(make_triple(int(ST_FM), k, j));
+                }
+                break;
+                }
+            } else { assert(!"unreachable"); }
+        } 
+        break;
+#endif
+
+        case ST_FM:
+            if (0 < i && i+2 <= j && j < L2) // ???
+            {
+                RealT outside = FMo[offset[i]+j] - Z;
+                Roulette<int,RealT> roulette;
+
+                // compute SUM (i<k<j : FM1[i,k] + FM[k,j]) 
+                for (int k=i+1; k < j; k++)
+                {
+                    RealT FM2i = FM1i[offset[i]+k] + FMi[offset[k]+j];
+                    roulette.add(EncodeTraceback(TB_FM_BIFURCATION, k), Fast_Exp(outside + FM2i));
+                }
+
+                // compute FM[i,j-1] + b
+                if (allow_unpaired_position[j])
+                {
+                    roulette.add(EncodeTraceback(TB_FM_UNPAIRED,0),
+                                 Fast_Exp(outside + FMi[offset[i]+j-1] + ScoreMultiUnpaired(j)));
+                }
+
+                // compute FM1[i,j]
+                roulette.add(EncodeTraceback(TB_FM_FM1,0), Fast_Exp(outside + FM1i[offset[i]+j]));
+
+                // choose
+                std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                switch (traceback.first)
+                {
+                case TB_FM_BIFURCATION:
+                {
+                    const int k = traceback.second;
+                    traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                    traceback_queue.push(make_triple(int(ST_FM), k, j));
+                }
+                break;
+                case TB_FM_UNPAIRED:
+                {
+                    traceback_queue.push(make_triple(int(ST_FM), i, j-1));
+                }
+                break;
+                case TB_FM_FM1: 
+                {
+                    traceback_queue.push(make_triple(int(ST_FM1), i, j));
+                }
+                break;
+                }
+                
+            } else { assert(!"unreachable"); }
+            break;
+
+        case ST_FM1:
+            if (0 < i && i+2 <= j && j < L2) // ???
+            {
+                Roulette<int,RealT> roulette;
+
+                // compute FC[i+1,j-1] + ScoreJunctionA(j,i) + c + ScoreBP(i+1,j)
+                if (allow_paired[offset[i+1]+j])
+                {
+                    RealT value = Fast_Exp(FM1o[offset[i]+j] + FCi[offset[i+1]+j-1] + ScoreJunctionA(j,i) +
+                                           ScoreMultiPaired() + ScoreBasePair(i+1,j) - Z);
+                    roulette.add(EncodeTraceback(TB_FM1_PAIRED, 0), value);
+                }
+                
+                // compute FM1[i+1,j] + b
+                if (allow_unpaired_position[i+1])
+                {
+                    roulette.add(EncodeTraceback(TB_FM1_UNPAIRED,0),
+                                 Fast_Exp(FM1o[offset[i]+j] + FM1i[offset[i+1]+j] + ScoreMultiUnpaired(i+1) - Z));
+                }
+
+                // choose
+                std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                switch (traceback.first)
+                {
+                case TB_FM1_PAIRED:
+                {
+                    solution[i+1] = j;
+                    solution[j] = i+1;
+                    traceback_queue.push(make_triple(int(ST_FC), i+1, j-1));
+                }
+                break;
+                case TB_FM1_UNPAIRED:
+                {
+                    traceback_queue.push(make_triple(int(ST_FM1), i+1, j));
+                }
+                break;
+                }
+            } else { assert(!"unreachable"); }
+            break;
+
+        case ST_F5:
+            if (j!=0)
+            {
+                Roulette<int,RealT> roulette;
+                RealT outside = F5o[j] - Z;
+
+                // compute F5[j-1] + ScoreExternalUnpaired()
+                if (allow_unpaired_position[j])
+                {
+                    roulette.add(EncodeTraceback(TB_F5_UNPAIRED,0),
+                                 Fast_Exp(outside + F5i[j-1] + ScoreExternalUnpaired(j)));
+                }
+        
+                // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
+                int l = max_bp_dist==0 ? 0 : std::max(0,j-max_bp_dist);
+                for (int k = l; k < j; k++)
+                {
+                    if (allow_paired[offset[k+1]+j])
+                    {
+                        RealT value = Fast_Exp(outside + F5i[k] + FCi[offset[k+1]+j-1] + ScoreExternalPaired() +
+                                               ScoreBasePair(k+1,j) + ScoreJunctionA(j,k));
+                        roulette.add(EncodeTraceback(TB_F5_BIFURCATION,k), value);
+                    }      
+                }
+
+                // choose
+                std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                switch (traceback.first)
+                {
+                case TB_F5_ZERO:
+                    break;
+                case TB_F5_UNPAIRED:
+                {
+                    traceback_queue.push(make_triple(int(ST_F5), 0, j-1));
+                }
+                break;
+                case TB_F5_BIFURCATION:
+                {
+                    const int k = traceback.second;
+                    solution[k+1] = j;
+                    solution[j] = k+1;
+                    traceback_queue.push(make_triple(int(ST_F5), 0, k));
+                    traceback_queue.push(make_triple(int(ST_FC), k+1, j-1));
+                }
+                break;
+                }
+            }
+            break;
+
+        default:
+            break;
+        }
+    }
+
+    return solution;
+}
+
 //////////////////////////////////////////////////////////////////////
 // InferenceEngine::GetPosterior()
 //
@@ -4757,3 +5156,13 @@
         ret[i] = (posterior[i] >= posterior_cutoff ? posterior[i] : RealT(0));
     return ret;
 }
+
+template<class RealT>
+RealT *InferenceEngine<RealT>::GetPosterior(const RealT posterior_cutoff,
+					    std::vector<RealT>& p) const
+{
+    p.resize(SIZE);
+    for (int i = 0; i < SIZE; i++)
+        p[i] = (posterior[i] >= posterior_cutoff ? posterior[i] : RealT(0));
+    return &p[0];
+}
diff -urN contrafold_v2_02.orig/src/Makefile contrafold/src/Makefile
--- contrafold_v2_02.orig/src/Makefile	2008-08-14 09:08:30.000000000 +0900
+++ contrafold/src/Makefile	2008-10-27 10:55:12.922313520 +0900
@@ -1,4 +1,6 @@
 CXX = g++
+AR = ar
+RANLIB = ranlib
 
 CXXFLAGS = -O3 -DNDEBUG -W -pipe -Wundef -Winline --param large-function-growth=100000 -Wall
 LINKFLAGS = -lm
@@ -27,15 +29,22 @@
 	SStruct.cpp \
 	Utilities.cpp
 
+LIB_SRCS = \
+	wrapper.cpp \
+	SStruct.cpp \
+	Utilities.cpp
+
 CONTRAFOLD_OBJS = $(CONTRAFOLD_SRCS:%.cpp=%.o)
 MAKECOORDS_OBJS = $(MAKECOORDS_SRCS:%.cpp=%.o)
 PLOTRNA_OBJS = $(PLOTRNA_SRCS:%.cpp=%.o)
 SCOREPREDICTION_OBJS = $(SCOREPREDICTION_SRCS:%.cpp=%.o)
+LIB_OBJS = $(LIB_SRCS:%.cpp=%.o)
 
 .PHONY: all viz clean
 
-all: contrafold score_prediction
+all: contrafold score_prediction lib
 viz: make_coords plot_rna
+lib: libcontrafold.a 
 
 contrafold: $(CONTRAFOLD_OBJS)
 	$(CXX) $(CXXFLAGS) $(OTHERFLAGS) $(CONTRAFOLD_OBJS) $(LINKFLAGS) -o contrafold
@@ -55,6 +64,12 @@
 score_prediction: $(SCOREPREDICTION_OBJS)
 	$(CXX) $(CXXFLAGS) $(OTHERFLAGS) $(SCOREPREDICTION_OBJS) $(LINKFLAGS) -o score_prediction
 
+libcontrafold.a: $(LIB_OBJS)
+	$(AR) r libcontrafold.a $(LIB_OBJS)
+	$(RANLIB) libcontrafold.a
+
+wrapper.o: wrapper.cpp Defaults.ipp
+
 ##########################################
 
 gccathlon64:
@@ -103,4 +118,4 @@
 	$(CXX) $(CXXFLAGS) $(OTHERFLAGS) -c $<
 
 clean:
-	rm -f contrafold make_coords plot_rna score_prediction *.o Defaults.ipp
+	rm -f contrafold make_coords plot_rna score_prediction *.o Defaults.ipp libcontrafold.a
diff -urN contrafold_v2_02.orig/src/SStruct.cpp contrafold/src/SStruct.cpp
--- contrafold_v2_02.orig/src/SStruct.cpp	2008-08-14 09:08:30.000000000 +0900
+++ contrafold/src/SStruct.cpp	2008-10-27 10:55:12.922313520 +0900
@@ -639,3 +639,39 @@
     this->mapping = mapping;
     ValidateMapping(mapping);
 }
+
+
+// additional constructors
+SStruct::SStruct(const std::string& name, const std::string& seq)
+{
+  Assign(name, seq);
+}
+
+SStruct::SStruct(const std::string& name, const std::string& seq, const std::string& str)
+{
+  Assign(name, seq, str);
+}
+
+void SStruct::Assign(const std::string& name, const std::string& seq)
+{
+  // clear any previous data
+  std::vector<std::string>().swap(names);
+  std::vector<std::string>().swap(sequences);
+  std::vector<int>().swap(mapping);
+
+  names.push_back(name);
+  sequences.push_back("@");
+  for (size_t i = 0; i < seq.length(); i++) {
+    if (isspace(seq[i])) continue;
+    sequences.back() += seq[i];
+  }
+  mapping = std::vector<int>(sequences[0].length(), UNKNOWN);
+}
+
+void SStruct::Assign(const std::string& name, const std::string& seq, const std::string& str)
+{
+  Assign(name, seq);
+  std::string x = "@";
+  x += str;
+  mapping = ConvertParensToMapping(FilterParens(x));
+}
diff -urN contrafold_v2_02.orig/src/SStruct.hpp contrafold/src/SStruct.hpp
--- contrafold_v2_02.orig/src/SStruct.hpp	2008-08-14 09:08:31.000000000 +0900
+++ contrafold/src/SStruct.hpp	2008-10-27 10:55:12.922313520 +0900
@@ -57,12 +57,18 @@
     // constructor and destructor
     SStruct();
     SStruct(const std::string &filename);
+    SStruct(const std::string& name, const std::string& seq);
+    SStruct(const std::string& name, const std::string& seq, const std::string& str);
     SStruct(const SStruct &rhs);
     ~SStruct();
 
     // load sequence and struture from file
     void Load(const std::string &filename);
 
+    // load sequence and structure from std::string
+    void Assign(const std::string& name, const std::string& seq);
+    void Assign(const std::string& name, const std::string& seq, const std::string& str);
+
     // assignment operator
     const SStruct& operator=(const SStruct &rhs);
 
diff -urN contrafold_v2_02.orig/src/Utilities.cpp contrafold/src/Utilities.cpp
--- contrafold_v2_02.orig/src/Utilities.cpp	2008-08-14 09:08:31.000000000 +0900
+++ contrafold/src/Utilities.cpp	2008-10-27 10:55:12.926313945 +0900
@@ -3,6 +3,7 @@
 //////////////////////////////////////////////////////////////////////
 
 #include "Utilities.hpp"
+#include <climits>
 
 bool toggle_error = false;
 
diff -urN contrafold_v2_02.orig/src/contrafold.h contrafold/src/contrafold.h
--- contrafold_v2_02.orig/src/contrafold.h	1970-01-01 09:00:00.000000000 +0900
+++ contrafold/src/contrafold.h	2008-10-27 16:19:11.065440421 +0900
@@ -0,0 +1,56 @@
+/*
+ * wrapper routines for CONTRAfold
+ *
+ * Copyright (C) 2008 Kengo Sato
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __INC_CONTRAFOLD_H__
+#define __INC_CONTRAFOLD_H__
+
+#include <string>
+
+template < class T >
+class CONTRAfold
+{
+private:
+  struct Impl;
+
+public:
+  CONTRAfold(bool canonical_only = true, int max_bp_dist = 0);
+  ~CONTRAfold();
+
+  void SetParameters(const std::string& params);
+  void SetConstraint(const std::string& paren);
+  
+  const T* ComputePosterior(const std::string& seq);
+  const T* ComputePosterior(const std::string& seq, std::vector<T>& p);
+
+  void PrepareStochasticTraceback(const std::string& seq);
+  std::vector<int> StochasticTraceback() const;
+
+  int max_bp_dist() const { return max_bp_dist_; }
+  
+private:
+  Impl* impl_;
+  int max_bp_dist_;
+};
+
+#endif	// __INC_CONTRAFOLD_H__
+
+// Local Variables:
+// mode: C++
+// End:
diff -urN contrafold_v2_02.orig/src/wrapper.cpp contrafold/src/wrapper.cpp
--- contrafold_v2_02.orig/src/wrapper.cpp	1970-01-01 09:00:00.000000000 +0900
+++ contrafold/src/wrapper.cpp	2008-10-27 16:30:36.385942665 +0900
@@ -0,0 +1,191 @@
+// 
+#include <vector>
+#include <string>
+#include "InferenceEngine.hpp"
+#include "ParameterManager.hpp"
+#include "SStruct.hpp"
+#include "Defaults.ipp"
+#include "contrafold.h"
+
+template < class T > 
+struct CONTRAfold<T>::Impl
+{
+  Impl(bool canonical_only, int max_bp_dist);
+  ~Impl() {};
+
+  void SetParameters(const std::string& params);
+  void SetConstraint(const std::string& paren);
+  
+  const T* ComputePosterior(const std::string& seq);
+  const T* ComputePosterior(const std::string& seq, std::vector<T>& p);
+
+  void PrepareStochasticTraceback(const std::string& seq);
+  std::vector<int> StochasticTraceback() const;
+
+  ParameterManager<T> pm_;
+  InferenceEngine<T> engine_;
+  std::vector<T> w_;
+  std::string paren_;
+};
+
+template < class T >
+CONTRAfold<T>::
+CONTRAfold(bool canonical_only, int max_bp_dist)
+  : impl_(new Impl(canonical_only, max_bp_dist)), max_bp_dist_(max_bp_dist)
+{
+}
+
+template < class T >
+CONTRAfold<T>::
+~CONTRAfold()
+{
+  delete impl_;
+}
+
+template < class T >
+void
+CONTRAfold<T>::
+SetParameters(const std::string& params)
+{
+  impl_->SetParameters(params);
+}
+
+template < class T >
+void
+CONTRAfold<T>::
+SetConstraint(const std::string& paren)
+{
+  impl_->SetConstraint(paren);
+}
+
+template < class T >
+const T* 
+CONTRAfold<T>::
+ComputePosterior(const std::string& seq)
+{
+  return impl_->ComputePosterior(seq);
+}
+
+template < class T >
+const T* 
+CONTRAfold<T>::
+ComputePosterior(const std::string& seq, std::vector<T>& p)
+{
+  return impl_->ComputePosterior(seq, p);
+}
+
+template < class T >
+void
+CONTRAfold<T>::
+PrepareStochasticTraceback(const std::string& seq)
+{
+  return impl_->PrepareStochasticTraceback(seq);
+}
+
+template < class T >
+std::vector<int>
+CONTRAfold<T>::
+StochasticTraceback() const
+{
+  return impl_->StochasticTraceback();
+}
+
+template < class T > 
+CONTRAfold<T>::Impl::
+Impl(bool canonical_only, int max_bp_dist)
+  : pm_(), engine_(!canonical_only, max_bp_dist), paren_()
+{
+  engine_.RegisterParameters(pm_);
+  if (canonical_only)
+    w_ = GetDefaultComplementaryValues<float>();
+  else
+    w_ = GetDefaultNoncomplementaryValues<float>();
+}
+
+template < class T >
+void
+CONTRAfold<T>::Impl::
+SetParameters(const std::string& params)
+{
+  pm_.ReadFromFile(params, w_);
+}
+
+template < class T >
+void
+CONTRAfold<T>::Impl::
+SetConstraint(const std::string& paren)
+{
+  paren_ = paren;
+}
+
+template < class T > 
+const T*
+CONTRAfold<T>::Impl::
+ComputePosterior(const std::string& seq)
+{
+  SStruct* s=NULL;
+  if (paren_.empty())
+    s = new SStruct("unknown", seq);
+  else
+    s = new SStruct("unknown", seq, paren_);
+  engine_.LoadSequence(*s);
+  if (!paren_.empty())
+    engine_.UseConstraints(s->GetMapping());
+  engine_.LoadValues(w_);
+  engine_.ComputeInside();
+  engine_.ComputeOutside();
+  engine_.ComputePosterior();
+  delete s;
+  return engine_.GetPosterior(0.0);
+}
+
+template < class T > 
+const T*
+CONTRAfold<T>::Impl::
+ComputePosterior(const std::string& seq, std::vector<T>& p)
+{
+  SStruct* s=NULL;
+  if (paren_.empty())
+    s = new SStruct("unknown", seq);
+  else
+    s = new SStruct("unknown", seq, paren_);
+  engine_.LoadSequence(*s);
+  if (!paren_.empty())
+    engine_.UseConstraints(s->GetMapping());
+  engine_.LoadValues(w_);
+  engine_.ComputeInside();
+  engine_.ComputeOutside();
+  engine_.ComputePosterior();
+  delete s;
+  return engine_.GetPosterior(0.0, p);
+}
+
+template < class T > 
+void
+CONTRAfold<T>::Impl::
+PrepareStochasticTraceback(const std::string& seq)
+{
+  SStruct* s=NULL;
+  if (paren_.empty())
+    s = new SStruct("unknown", seq);
+  else
+    s = new SStruct("unknown", seq, paren_);
+  engine_.LoadSequence(*s);
+  if (!paren_.empty())
+    engine_.UseConstraints(s->GetMapping());
+  engine_.LoadValues(w_);
+  engine_.ComputeInside();
+  engine_.ComputeOutside();
+  delete s;
+}
+
+template < class T > 
+std::vector<int>
+CONTRAfold<T>::Impl::
+StochasticTraceback() const
+{
+  return engine_.PredictPairingsStochasticTraceback();
+}
+
+template
+class CONTRAfold<float>;
